import { createRequire } from 'module';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const require = createRequire(import.meta.url);

// Load dependencies with fallback paths
function findModule(moduleName) {
  const possiblePaths = [
    path.join(__dirname, 'node_modules', moduleName),
    path.join(__dirname, '..', 'node_modules', moduleName),
    path.join(__dirname, '..', '..', 'node_modules', moduleName),
    path.join(process.resourcesPath || '', '..', 'node_modules', moduleName),
  ];

  for (const modulePath of possiblePaths) {
    try {
      require.resolve(modulePath);
      return require(modulePath);
    } catch (e) {
      // Continue searching
    }
  }

  try {
    return require(moduleName);
  } catch (e) {
    console.error(`Failed to find module ${moduleName}`);
    throw e;
  }
}

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const jwt = findModule('jsonwebtoken');
const bcrypt = findModule('bcrypt');

// Configuration
const AUTH_CONFIG_FILE = path.join(__dirname, '..', 'auth-config.json');
const DEFAULT_JWT_SECRET = process.env.JWT_SECRET || 'tankmon-jwt-secret-change-in-production';
const JWT_EXPIRY = '24h';
const SALT_ROUNDS = 10;

// In-memory user store (in production, use a database)
let users = {};
let jwtSecret = DEFAULT_JWT_SECRET;

// Initialize auth configuration
async function initAuthConfig() {
  try {
    const configData = await fs.readFile(AUTH_CONFIG_FILE, 'utf8');
    const config = JSON.parse(configData);
    users = config.users || {};
    jwtSecret = config.jwtSecret || DEFAULT_JWT_SECRET;
    console.log('Auth configuration loaded');
  } catch (error) {
    console.log('No auth config found, creating default');
    // Create default admin user
    const hashedPassword = await bcrypt.hash('admin', SALT_ROUNDS);
    users = {
      admin: {
        username: 'admin',
        password: hashedPassword,
        role: 'admin',
        createdAt: new Date().toISOString()
      }
    };
    await saveAuthConfig();
  }
}

// Save auth configuration
async function saveAuthConfig() {
  try {
    const config = {
      users,
      jwtSecret,
      lastUpdated: new Date().toISOString()
    };
    await fs.writeFile(AUTH_CONFIG_FILE, JSON.stringify(config, null, 2));
    console.log('Auth configuration saved');
  } catch (error) {
    console.error('Error saving auth config:', error);
  }
}

// Generate JWT token
function generateToken(user) {
  const payload = {
    username: user.username,
    role: user.role,
    iat: Date.now()
  };
  
  return jwt.sign(payload, jwtSecret, {
    expiresIn: JWT_EXPIRY,
    algorithm: 'HS256'
  });
}

// Verify JWT token
export function verifyToken(token) {
  try {
    return jwt.verify(token, jwtSecret, {
      algorithms: ['HS256']
    });
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// Authentication middleware
export function authenticate(req, res, next) {
  // Skip authentication for certain routes
  const publicRoutes = [
    '/api/auth/login',
    '/api/auth/verify',
    '/api/auth/status',
    '/login',
    '/login.html'
  ];
  
  // Skip auth for static assets and public routes
  const skipAuth = publicRoutes.some(route => req.path === route) ||
                   req.path.startsWith('/assets/') ||
                   req.path.endsWith('.css') ||
                   req.path.endsWith('.js') ||
                   req.path.endsWith('.png') ||
                   req.path.endsWith('.jpg') ||
                   req.path.endsWith('.ico');
  
  if (skipAuth) {
    return next();
  }

  // Extract token from header
  const authHeader = req.headers.authorization;
  const token = authHeader && authHeader.startsWith('Bearer ') 
    ? authHeader.substring(7) 
    : null;

  if (!token) {
    return res.status(401).json({ 
      error: 'Authentication required',
      message: 'No token provided'
    });
  }

  try {
    const decoded = verifyToken(token);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ 
      error: 'Authentication failed',
      message: error.message
    });
  }
}

// Login function
export async function login(username, password) {
  const user = users[username];
  
  if (!user) {
    throw new Error('Invalid credentials');
  }

  const validPassword = await bcrypt.compare(password, user.password);
  
  if (!validPassword) {
    throw new Error('Invalid credentials');
  }

  const token = generateToken(user);
  
  return {
    token,
    user: {
      username: user.username,
      role: user.role
    }
  };
}

// Change password function
export async function changePassword(username, oldPassword, newPassword) {
  const user = users[username];
  
  if (!user) {
    throw new Error('User not found');
  }

  const validPassword = await bcrypt.compare(oldPassword, user.password);
  
  if (!validPassword) {
    throw new Error('Invalid old password');
  }

  // Validate new password
  if (newPassword.length < 6) {
    throw new Error('Password must be at least 6 characters long');
  }

  const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);
  users[username].password = hashedPassword;
  users[username].passwordChangedAt = new Date().toISOString();
  
  await saveAuthConfig();
  
  return { success: true, message: 'Password changed successfully' };
}

// Create new user function (admin only)
export async function createUser(adminUsername, newUsername, newPassword, role = 'user') {
  const admin = users[adminUsername];
  
  if (!admin || admin.role !== 'admin') {
    throw new Error('Unauthorized: Admin access required');
  }

  if (users[newUsername]) {
    throw new Error('User already exists');
  }

  if (newPassword.length < 6) {
    throw new Error('Password must be at least 6 characters long');
  }

  const hashedPassword = await bcrypt.hash(newPassword, SALT_ROUNDS);
  
  users[newUsername] = {
    username: newUsername,
    password: hashedPassword,
    role,
    createdAt: new Date().toISOString(),
    createdBy: adminUsername
  };

  await saveAuthConfig();
  
  return {
    success: true,
    user: {
      username: newUsername,
      role
    }
  };
}

// Delete user function (admin only)
export async function deleteUser(adminUsername, targetUsername) {
  const admin = users[adminUsername];
  
  if (!admin || admin.role !== 'admin') {
    throw new Error('Unauthorized: Admin access required');
  }

  if (!users[targetUsername]) {
    throw new Error('User not found');
  }

  if (targetUsername === adminUsername) {
    throw new Error('Cannot delete your own account');
  }

  delete users[targetUsername];
  await saveAuthConfig();
  
  return { success: true, message: 'User deleted successfully' };
}

// List users function (admin only)
export function listUsers(adminUsername) {
  const admin = users[adminUsername];
  
  if (!admin || admin.role !== 'admin') {
    throw new Error('Unauthorized: Admin access required');
  }

  return Object.values(users).map(user => ({
    username: user.username,
    role: user.role,
    createdAt: user.createdAt,
    createdBy: user.createdBy,
    passwordChangedAt: user.passwordChangedAt
  }));
}

// Initialize on module load
await initAuthConfig();